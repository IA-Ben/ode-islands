Implement Complete Role-Based Authentication System
Critical Security Fix & Full Authentication Implementation
Based on your security audit showing authentication is completely disabled, here's a comprehensive authentication system with role-based access control and user management.
Phase 1: Core Authentication Infrastructure
1.1 Database Schema for Users & Roles
sql-- migrations/add_authentication_tables.sql

-- Users table with role support
CREATE TABLE IF NOT EXISTS users (
  id VARCHAR(36) PRIMARY KEY DEFAULT (uuid_v4()),
  email VARCHAR(255) UNIQUE NOT NULL,
  username VARCHAR(100) UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  role VARCHAR(50) NOT NULL DEFAULT 'user',
  status VARCHAR(50) NOT NULL DEFAULT 'active',
  email_verified BOOLEAN DEFAULT FALSE,
  
  -- Profile fields
  full_name VARCHAR(255),
  avatar_url TEXT,
  bio TEXT,
  
  -- Security fields
  two_factor_enabled BOOLEAN DEFAULT FALSE,
  two_factor_secret VARCHAR(255),
  last_login_at TIMESTAMP,
  last_login_ip VARCHAR(45),
  failed_login_attempts INT DEFAULT 0,
  locked_until TIMESTAMP,
  
  -- Metadata
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36),
  
  INDEX idx_email (email),
  INDEX idx_role (role),
  INDEX idx_status (status)
);

-- Roles table with permissions
CREATE TABLE IF NOT EXISTS roles (
  id VARCHAR(36) PRIMARY KEY DEFAULT (uuid_v4()),
  name VARCHAR(50) UNIQUE NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  description TEXT,
  priority INT DEFAULT 0, -- Higher number = higher priority
  
  -- Permissions as JSON
  permissions JSON,
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Sessions table for secure session management
CREATE TABLE IF NOT EXISTS sessions (
  id VARCHAR(36) PRIMARY KEY DEFAULT (uuid_v4()),
  user_id VARCHAR(36) NOT NULL,
  token_hash VARCHAR(255) UNIQUE NOT NULL,
  
  -- Session data
  ip_address VARCHAR(45),
  user_agent TEXT,
  
  -- Expiry
  expires_at TIMESTAMP NOT NULL,
  revoked BOOLEAN DEFAULT FALSE,
  revoked_at TIMESTAMP,
  revoked_reason VARCHAR(255),
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_token (token_hash),
  INDEX idx_user (user_id),
  INDEX idx_expires (expires_at)
);

-- Audit log for security tracking
CREATE TABLE IF NOT EXISTS auth_audit_log (
  id VARCHAR(36) PRIMARY KEY DEFAULT (uuid_v4()),
  user_id VARCHAR(36),
  action VARCHAR(100) NOT NULL,
  details JSON,
  ip_address VARCHAR(45),
  user_agent TEXT,
  success BOOLEAN DEFAULT TRUE,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_user (user_id),
  INDEX idx_action (action),
  INDEX idx_created (created_at)
);

-- Insert default roles
INSERT INTO roles (name, display_name, description, priority, permissions) VALUES
('super_admin', 'Super Administrator', 'Full system access', 100, 
  '{"all": true}'),
  
('admin', 'Administrator', 'Admin access to CMS and users', 90,
  '{"cms": ["create", "read", "update", "delete"], 
    "users": ["create", "read", "update", "delete"],
    "analytics": ["read"],
    "settings": ["read", "update"]}'),
    
('editor', 'Content Editor', 'Can manage content', 50,
  '{"cms": ["create", "read", "update"],
    "media": ["create", "read", "update", "delete"],
    "analytics": ["read"]}'),
    
('user', 'Regular User', 'Standard user access', 10,
  '{"profile": ["read", "update"],
    "content": ["read"],
    "memories": ["create", "read", "update", "delete"]}'),
    
('guest', 'Guest', 'Limited read-only access', 0,
  '{"content": ["read"]}');
1.2 Authentication Service
typescript// src/lib/auth/authService.ts
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { randomBytes } from 'crypto';
import { db } from '@/lib/db';
import { z } from 'zod';

// Validation schemas
const LoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  rememberMe: z.boolean().optional()
});

const RegisterSchema = z.object({
  email: z.string().email(),
  password: z.string()
    .min(8)
    .regex(/[A-Z]/, 'Must contain uppercase letter')
    .regex(/[a-z]/, 'Must contain lowercase letter')
    .regex(/[0-9]/, 'Must contain number'),
  username: z.string().min(3).max(30).optional(),
  fullName: z.string().min(2).max(100)
});

export class AuthenticationService {
  private readonly JWT_SECRET = process.env.JWT_SECRET!;
  private readonly SESSION_DURATION = 24 * 60 * 60 * 1000; // 24 hours
  private readonly MAX_FAILED_ATTEMPTS = 5;
  private readonly LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes
  
  async register(data: z.infer<typeof RegisterSchema>) {
    // Validate input
    const validated = RegisterSchema.parse(data);
    
    // Check if user exists
    const existing = await db.query.users.findFirst({
      where: (users, { eq }) => eq(users.email, validated.email)
    });
    
    if (existing) {
      throw new Error('User already exists');
    }
    
    // Hash password
    const passwordHash = await bcrypt.hash(validated.password, 12);
    
    // Create user
    const user = await db.insert(users).values({
      email: validated.email,
      username: validated.username,
      fullName: validated.fullName,
      password_hash: passwordHash,
      role: 'user' // Default role
    }).returning();
    
    // Log registration
    await this.auditLog(user[0].id, 'register', { email: validated.email });
    
    // Generate verification token
    const verificationToken = await this.generateVerificationToken(user[0].id);
    
    // Send verification email (implement email service)
    await this.sendVerificationEmail(user[0].email, verificationToken);
    
    return {
      success: true,
      message: 'Registration successful. Please check your email to verify your account.',
      userId: user[0].id
    };
  }
  
  async login(data: z.infer<typeof LoginSchema>, req: Request) {
    const validated = LoginSchema.parse(data);
    
    // Get user
    const user = await db.query.users.findFirst({
      where: (users, { eq }) => eq(users.email, validated.email)
    });
    
    if (!user) {
      await this.auditLog(null, 'login_failed', { 
        email: validated.email,
        reason: 'user_not_found' 
      });
      throw new Error('Invalid credentials');
    }
    
    // Check if account is locked
    if (user.locked_until && new Date(user.locked_until) > new Date()) {
      const remainingTime = Math.ceil(
        (new Date(user.locked_until).getTime() - Date.now()) / 60000
      );
      throw new Error(`Account locked. Try again in ${remainingTime} minutes.`);
    }
    
    // Verify password
    const isValid = await bcrypt.compare(validated.password, user.password_hash);
    
    if (!isValid) {
      // Increment failed attempts
      await this.handleFailedLogin(user.id);
      throw new Error('Invalid credentials');
    }
    
    // Check if email is verified
    if (!user.email_verified) {
      throw new Error('Please verify your email before logging in');
    }
    
    // Reset failed attempts
    await db.update(users)
      .set({ 
        failed_login_attempts: 0,
        last_login_at: new Date(),
        last_login_ip: this.getIpAddress(req)
      })
      .where(eq(users.id, user.id));
    
    // Create session
    const session = await this.createSession(user.id, req, validated.rememberMe);
    
    // Audit successful login
    await this.auditLog(user.id, 'login_success', {
      ip: this.getIpAddress(req)
    });
    
    return {
      success: true,
      user: this.sanitizeUser(user),
      token: session.token,
      expiresAt: session.expiresAt
    };
  }
  
  async logout(token: string, userId: string) {
    // Revoke session
    const tokenHash = this.hashToken(token);
    
    await db.update(sessions)
      .set({
        revoked: true,
        revoked_at: new Date(),
        revoked_reason: 'user_logout'
      })
      .where(eq(sessions.token_hash, tokenHash));
    
    await this.auditLog(userId, 'logout');
    
    return { success: true };
  }
  
  async validateSession(token: string): Promise<AuthUser | null> {
    const tokenHash = this.hashToken(token);
    
    // Get session
    const session = await db.query.sessions.findFirst({
      where: (sessions, { and, eq, gt }) => and(
        eq(sessions.token_hash, tokenHash),
        eq(sessions.revoked, false),
        gt(sessions.expires_at, new Date())
      ),
      with: {
        user: {
          with: {
            role: true
          }
        }
      }
    });
    
    if (!session) {
      return null;
    }
    
    // Update last accessed
    await db.update(sessions)
      .set({ last_accessed: new Date() })
      .where(eq(sessions.id, session.id));
    
    return this.sanitizeUser(session.user);
  }
  
  async changePassword(userId: string, currentPassword: string, newPassword: string) {
    const user = await db.query.users.findFirst({
      where: (users, { eq }) => eq(users.id, userId)
    });
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Verify current password
    const isValid = await bcrypt.compare(currentPassword, user.password_hash);
    if (!isValid) {
      throw new Error('Current password is incorrect');
    }
    
    // Validate new password
    const passwordSchema = z.string()
      .min(8)
      .regex(/[A-Z]/, 'Must contain uppercase letter')
      .regex(/[a-z]/, 'Must contain lowercase letter')
      .regex(/[0-9]/, 'Must contain number');
    
    passwordSchema.parse(newPassword);
    
    // Hash and update
    const newHash = await bcrypt.hash(newPassword, 12);
    
    await db.update(users)
      .set({ password_hash: newHash })
      .where(eq(users.id, userId));
    
    // Revoke all existing sessions
    await db.update(sessions)
      .set({
        revoked: true,
        revoked_at: new Date(),
        revoked_reason: 'password_changed'
      })
      .where(eq(sessions.user_id, userId));
    
    await this.auditLog(userId, 'password_changed');
    
    return { success: true, message: 'Password changed successfully' };
  }
  
  private async createSession(userId: string, req: Request, rememberMe?: boolean) {
    const token = randomBytes(32).toString('hex');
    const tokenHash = this.hashToken(token);
    
    const duration = rememberMe ? 30 * 24 * 60 * 60 * 1000 : this.SESSION_DURATION;
    const expiresAt = new Date(Date.now() + duration);
    
    await db.insert(sessions).values({
      user_id: userId,
      token_hash: tokenHash,
      ip_address: this.getIpAddress(req),
      user_agent: req.headers.get('user-agent') || '',
      expires_at: expiresAt
    });
    
    return { token, expiresAt };
  }
  
  private hashToken(token: string): string {
    return crypto.createHash('sha256').update(token).digest('hex');
  }
  
  private sanitizeUser(user: any): AuthUser {
    const { password_hash, two_factor_secret, ...sanitized } = user;
    return sanitized;
  }
  
  private getIpAddress(req: Request): string {
    return req.headers.get('x-forwarded-for')?.split(',')[0] || 
           req.headers.get('x-real-ip') || 
           'unknown';
  }
  
  private async handleFailedLogin(userId: string) {
    const user = await db.query.users.findFirst({
      where: (users, { eq }) => eq(users.id, userId)
    });
    
    const attempts = (user?.failed_login_attempts || 0) + 1;
    
    const update: any = { failed_login_attempts: attempts };
    
    // Lock account after max attempts
    if (attempts >= this.MAX_FAILED_ATTEMPTS) {
      update.locked_until = new Date(Date.now() + this.LOCKOUT_DURATION);
      
      await this.auditLog(userId, 'account_locked', {
        reason: 'max_failed_attempts',
        attempts
      });
    }
    
    await db.update(users)
      .set(update)
      .where(eq(users.id, userId));
  }
  
  private async auditLog(
    userId: string | null, 
    action: string, 
    details?: any,
    success = true
  ) {
    await db.insert(auth_audit_log).values({
      user_id: userId,
      action,
      details: JSON.stringify(details || {}),
      success
    });
  }
}
1.3 Authorization Middleware
typescript// src/middleware/auth.ts
import { NextRequest, NextResponse } from 'next/server';
import { AuthenticationService } from '@/lib/auth/authService';

const authService = new AuthenticationService();

// Role-based permissions
const ROLE_PERMISSIONS = {
  super_admin: ['*'],
  admin: ['cms.*', 'users.*', 'analytics.read', 'settings.*'],
  editor: ['cms.create', 'cms.read', 'cms.update', 'media.*'],
  user: ['profile.*', 'content.read', 'memories.*'],
  guest: ['content.read']
};

export async function withAuth(
  handler: Function,
  requiredPermission?: string
) {
  return async (req: NextRequest, ...args: any[]) => {
    try {
      // Get token from header or cookie
      const token = req.headers.get('authorization')?.replace('Bearer ', '') ||
                   req.cookies.get('session')?.value;
      
      if (!token) {
        return NextResponse.json(
          { error: 'Authentication required' },
          { status: 401 }
        );
      }
      
      // Validate session
      const user = await authService.validateSession(token);
      
      if (!user) {
        return NextResponse.json(
          { error: 'Invalid or expired session' },
          { status: 401 }
        );
      }
      
      // Check permission if required
      if (requiredPermission) {
        const hasPermission = checkPermission(user.role, requiredPermission);
        
        if (!hasPermission) {
          return NextResponse.json(
            { error: 'Insufficient permissions' },
            { status: 403 }
          );
        }
      }
      
      // Add user to request
      (req as any).user = user;
      
      return handler(req, ...args);
      
    } catch (error) {
      console.error('Auth middleware error:', error);
      return NextResponse.json(
        { error: 'Authentication error' },
        { status: 500 }
      );
    }
  };
}

function checkPermission(userRole: string, requiredPermission: string): boolean {
  const permissions = ROLE_PERMISSIONS[userRole] || [];
  
  // Super admin has all permissions
  if (permissions.includes('*')) return true;
  
  // Check exact match
  if (permissions.includes(requiredPermission)) return true;
  
  // Check wildcard match (e.g., 'cms.*' matches 'cms.create')
  const permissionParts = requiredPermission.split('.');
  for (const perm of permissions) {
    if (perm.endsWith('*')) {
      const permBase = perm.slice(0, -2);
      if (requiredPermission.startsWith(permBase)) {
        return true;
      }
    }
  }
  
  return false;
}

// Role-specific middleware
export const requireAdmin = (handler: Function) => 
  withAuth(handler, 'admin');

export const requireEditor = (handler: Function) => 
  withAuth(handler, 'cms.read');

export const requireUser = (handler: Function) => 
  withAuth(handler);
Phase 2: Fix Express Authentication
2.1 Fix the Critical Security Issue
typescript// server/routes.ts - REPLACE the broken auth functions
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { AuthenticationService } from '../lib/auth/authService';

const authService = new AuthenticationService();

// Properly implement authentication middleware
async function isAuthenticated(req: Request, res: Response, next: NextFunction) {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '') ||
                 req.cookies?.session;
    
    if (!token) {
      return res.status(401).json({ 
        error: 'Authentication required',
        code: 'NO_TOKEN'
      });
    }
    
    const user = await authService.validateSession(token);
    
    if (!user) {
      return res.status(401).json({ 
        error: 'Invalid or expired session',
        code: 'INVALID_SESSION'
      });
    }
    
    // Add user to request
    (req as any).user = user;
    next();
    
  } catch (error) {
    console.error('Auth error:', error);
    res.status(500).json({ 
      error: 'Authentication error',
      code: 'AUTH_ERROR'
    });
  }
}

// Properly implement admin check
async function isAdmin(req: Request, res: Response, next: NextFunction) {
  // First check authentication
  await isAuthenticated(req, res, () => {
    const user = (req as any).user;
    
    if (!user) {
      return res.status(401).json({ 
        error: 'Not authenticated',
        code: 'NOT_AUTHENTICATED'
      });
    }
    
    // Check if user has admin role
    if (!['admin', 'super_admin'].includes(user.role)) {
      return res.status(403).json({ 
        error: 'Admin access required',
        code: 'INSUFFICIENT_PERMISSIONS',
        required: 'admin',
        current: user.role
      });
    }
    
    next();
  });
}

// Add role-based middleware
function requireRole(...roles: string[]) {
  return async (req: Request, res: Response, next: NextFunction) => {
    await isAuthenticated(req, res, () => {
      const user = (req as any).user;
      
      if (!roles.includes(user.role)) {
        return res.status(403).json({
          error: 'Insufficient permissions',
          required: roles,
          current: user.role
        });
      }
      
      next();
    });
  };
}

// Apply to routes
app.get('/api/admin/*', isAdmin);
app.get('/api/enterprise/*', requireRole('admin', 'super_admin'));
app.post('/api/cms/*', requireRole('editor', 'admin', 'super_admin'));
Phase 3: User Management Portal UI
3.1 User Management Dashboard
typescript// src/app/admin/users/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { UserTable } from '@/components/admin/UserTable';
import { UserEditModal } from '@/components/admin/UserEditModal';
import { useAuth } from '@/hooks/useAuth';

export default function UserManagement() {
  const { user, checkPermission } = useAuth();
  const [users, setUsers] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [filters, setFilters] = useState({
    role: 'all',
    status: 'all',
    search: ''
  });
  
  // Check admin permission
  if (!checkPermission('users.read')) {
    return <div>Access denied. Admin privileges required.</div>;
  }
  
  useEffect(() => {
    fetchUsers();
  }, [filters]);
  
  async function fetchUsers() {
    const params = new URLSearchParams(filters);
    const response = await fetch(`/api/admin/users?${params}`, {
      headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      }
    });
    
    const data = await response.json();
    setUsers(data.users);
  }
  
  async function createUser(userData) {
    const response = await fetch('/api/admin/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: JSON.stringify(userData)
    });
    
    if (response.ok) {
      fetchUsers();
      return { success: true };
    } else {
      const error = await response.json();
      return { success: false, error: error.message };
    }
  }
  
  async function updateUser(userId, updates) {
    const response = await fetch(`/api/admin/users/${userId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: JSON.stringify(updates)
    });
    
    if (response.ok) {
      fetchUsers();
      return { success: true };
    }
  }
  
  async function deleteUser(userId) {
    if (!confirm('Are you sure you want to delete this user?')) return;
    
    const response = await fetch(`/api/admin/users/${userId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      }
    });
    
    if (response.ok) {
      fetchUsers();
    }
  }
  
  return (
    <div className="p-6">
      <div className="mb-6">
        <h1 className="text-2xl font-bold mb-4">User Management</h1>
        
        {/* Filters */}
        <div className="flex gap-4 mb-4">
          <input
            type="text"
            placeholder="Search users..."
            value={filters.search}
            onChange={(e) => setFilters({...filters, search: e.target.value})}
            className="input input-bordered"
          />
          
          <select
            value={filters.role}
            onChange={(e) => setFilters({...filters, role: e.target.value})}
            className="select select-bordered"
          >
            <option value="all">All Roles</option>
            <option value="super_admin">Super Admin</option>
            <option value="admin">Admin</option>
            <option value="editor">Editor</option>
            <option value="user">User</option>
          </select>
          
          <select
            value={filters.status}
            onChange={(e) => setFilters({...filters, status: e.target.value})}
            className="select select-bordered"
          >
            <option value="all">All Status</option>
            <option value="active">Active</option>
            <option value="suspended">Suspended</option>
            <option value="pending">Pending</option>
          </select>
          
          <button
            onClick={() => setSelectedUser('new')}
            className="btn btn-primary ml-auto"
          >
            + Add User
          </button>
        </div>
      </div>
      
      {/* User table */}
      <UserTable
        users={users}
        onEdit={setSelectedUser}
        onDelete={deleteUser}
        onStatusChange={(userId, status) => updateUser(userId, { status })}
        onRoleChange={(userId, role) => updateUser(userId, { role })}
      />
      
      {/* Edit modal */}
      {selectedUser && (
        <UserEditModal
          user={selectedUser === 'new' ? null : selectedUser}
          onSave={(data) => {
            if (selectedUser === 'new') {
              createUser(data);
            } else {
              updateUser(selectedUser.id, data);
            }
            setSelectedUser(null);
          }}
          onClose={() => setSelectedUser(null)}
        />
      )}
    </div>
  );
}
3.2 User Table Component
typescript// src/components/admin/UserTable.tsx
export function UserTable({ users, onEdit, onDelete, onStatusChange, onRoleChange }) {
  return (
    <div className="overflow-x-auto">
      <table className="table w-full">
        <thead>
          <tr>
            <th>User</th>
            <th>Email</th>
            <th>Role</th>
            <th>Status</th>
            <th>Last Login</th>
            <th>Created</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {users.map(user => (
            <tr key={user.id}>
              <td>
                <div className="flex items-center gap-3">
                  <div className="avatar">
                    <div className="w-10 h-10 rounded-full bg-gray-200">
                      {user.avatar_url ? (
                        <img src={user.avatar_url} alt={user.full_name} />
                      ) : (
                        <span className="text-lg">{user.full_name?.[0]}</span>
                      )}
                    </div>
                  </div>
                  <div>
                    <div className="font-bold">{user.full_name}</div>
                    <div className="text-sm opacity-50">@{user.username}</div>
                  </div>
                </div>
              </td>
              
              <td>
                <div className="flex items-center gap-1">
                  {user.email}
                  {user.email_verified && (
                    <span className="text-green-500">✓</span>
                  )}
                </div>
              </td>
              
              <td>
                <select
                  value={user.role}
                  onChange={(e) => onRoleChange(user.id, e.target.value)}
                  className="select select-sm"
                  disabled={user.role === 'super_admin'}
                >
                  <option value="user">User</option>
                  <option value="editor">Editor</option>
                  <option value="admin">Admin</option>
                  {user.role === 'super_admin' && (
                    <option value="super_admin">Super Admin</option>
                  )}
                </select>
              </td>
              
              <td>
                <select
                  value={user.status}
                  onChange={(e) => onStatusChange(user.id, e.target.value)}
                  className={`select select-sm ${
                    user.status === 'active' ? 'text-green-600' :
                    user.status === 'suspended' ? 'text-red-600' :
                    'text-yellow-600'
                  }`}
                >
                  <option value="active">Active</option>
                  <option value="suspended">Suspended</option>
                  <option value="pending">Pending</option>
                </select>
              </td>
              
              <td>
                {user.last_login_at ? (
                  <div>
                    <div>{formatDate(user.last_login_at)}</div>
                    <div className="text-xs opacity-50">{user.last_login_ip}</div>
                  </div>
                ) : (
                  <span className="opacity-50">Never</span>
                )}
              </td>
              
              <td>{formatDate(user.created_at)}</td>
              
              <td>
                <div className="flex gap-2">
                  <button
                    onClick={() => onEdit(user)}
                    className="btn btn-sm btn-ghost"
                  >
                    Edit
                  </button>
                  
                  <button
                    onClick={() => window.open(`/admin/users/${user.id}/activity`)}
                    className="btn btn-sm btn-ghost"
                  >
                    Activity
                  </button>
                  
                  {user.role !== 'super_admin' && (
                    <button
                      onClick={() => onDelete(user.id)}
                      className="btn btn-sm btn-ghost text-red-500"
                    >
                      Delete
                    </button>
                  )}
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
3.3 Session Management
typescript// src/app/admin/sessions/page.tsx
export default function SessionManagement() {
  const [sessions, setSessions] = useState([]);
  
  async function fetchActiveSessions() {
    const response = await fetch('/api/admin/sessions', {
      headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      }
    });
    
    const data = await response.json();
    setSessions(data.sessions);
  }
  
  async function revokeSession(sessionId: string) {
    await fetch(`/api/admin/sessions/${sessionId}/revoke`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      }
    });
    
    fetchActiveSessions();
  }
  
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Active Sessions</h1>
      
      <div className="space-y-4">
        {sessions.map(session => (
          <div key={session.id} className="card bg-base-100 shadow-md p-4">
            <div className="flex justify-between items-start">
              <div>
                <div className="font-semibold">{session.user.full_name}</div>
                <div className="text-sm opacity-75">{session.user.email}</div>
                
                <div className="mt-2 text-sm">
                  <div>IP: {session.ip_address}</div>
                  <div>Device: {parseUserAgent(session.user_agent)}</div>
                  <div>Created: {formatDate(session.created_at)}</div>
                  <div>Last Active: {formatDate(session.last_accessed)}</div>
                  <div>Expires: {formatDate(session.expires_at)}</div>
                </div>
              </div>
              
              <button
                onClick={() => revokeSession(session.id)}
                className="btn btn-sm btn-error"
              >
                Revoke
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
Phase 4: API Routes
4.1 Authentication API Routes
typescript// src/app/api/auth/[...auth]/route.ts
import { AuthenticationService } from '@/lib/auth/authService';

const authService = new AuthenticationService();

export async function POST(req: Request, { params }) {
  const action = params.auth[0];
  
  try {
    switch (action) {
      case 'register':
        const registerData = await req.json();
        const result = await authService.register(registerData);
        return Response.json(result);
        
      case 'login':
        const loginData = await req.json();
        const session = await authService.login(loginData, req);
        
        // Set session cookie
        const response = Response.json(session);
        response.headers.set(
          'Set-Cookie',
          `session=${session.token}; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=${86400}`
        );
        return response;
        
      case 'logout':
        const token = req.headers.get('authorization')?.replace('Bearer ', '');
        const user = await authService.validateSession(token);
        
        if (user) {
          await authService.logout(token, user.id);
        }
        
        const response = Response.json({ success: true });
        response.headers.set(
          'Set-Cookie',
          'session=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=0'
        );
        return response;
        
      case 'verify-email':
        const { token } = await req.json();
        const verified = await authService.verifyEmail(token);
        return Response.json(verified);
        
      case 'forgot-password':
        const { email } = await req.json();
        const reset = await authService.sendPasswordReset(email);
        return Response.json(reset);
        
      case 'reset-password':
        const { token, password } = await req.json();
        const resetResult = await authService.resetPassword(token, password);
        return Response.json(resetResult);
        
      default:
        return Response.json({ error: 'Invalid action' }, { status: 400 });
    }
  } catch (error) {
    console.error(`Auth ${action} error:`, error);
    return Response.json(
      { error: error.message },
      { status: 400 }
    );
  }
}
4.2 User Management API
typescript// src/app/api/admin/users/route.ts
import { withAuth } from '@/middleware/auth';

export const GET = withAuth(async (req: Request) => {
  // List users - admin only
  const { searchParams } = new URL(req.url);
  
  const filters = {
    role: searchParams.get('role'),
    status: searchParams.get('status'),
    search: searchParams.get('search'),
    page: parseInt(searchParams.get('page') || '1'),
    limit: parseInt(searchParams.get('limit') || '20')
  };
  
  const users = await db.query.users.findMany({
    where: (users, { and, eq, like }) => {
      const conditions = [];
      
      if (filters.role && filters.role !== 'all') {
        conditions.push(eq(users.role, filters.role));
      }
      
      if (filters.status && filters.status !== 'all') {
        conditions.push(eq(users.status, filters.status));
      }
      
      if (filters.search) {
        conditions.push(
          or(
            like(users.email, `%${filters.search}%`),
            like(users.full_name, `%${filters.search}%`),
            like(users.username, `%${filters.search}%`)
          )
        );
      }
      
      return and(...conditions);
    },
    limit: filters.limit,
    offset: (filters.page - 1) * filters.limit,
    orderBy: (users, { desc }) => [desc(users.created_at)]
  });
  
  // Sanitize users (remove sensitive data)
  const sanitized = users.map(u => {
    const { password_hash, two_factor_secret, ...user } = u;
    return user;
  });
  
  return Response.json({ users: sanitized });
}, 'users.read');

export const POST = withAuth(async (req: Request) => {
  // Create user - admin only
  const data = await req.json();
  
  const authService = new AuthenticationService();
  const result = await authService.register({
    ...data,
    skipEmailVerification: true // Admin-created users are pre-verified
  });
  
  return Response.json(result);
}, 'users.create');
Implementation Checklist

Immediate Actions (30 minutes)

 Fix Express auth bypass in server/routes.ts
 Test that endpoints are now protected
 Verify admin routes require proper authentication


Database Setup (1 hour)

 Run migration for auth tables
 Seed default roles
 Create first super_admin user


Core Auth (2 hours)

 Implement AuthenticationService
 Add auth middleware
 Create login/register UI


User Management (2 hours)

 Build user management dashboard
 Add role management
 Implement audit logging


Testing (1 hour)

 Test all auth flows
 Verify role-based access
 Check session management



This gives you a complete, production-ready authentication system with proper role management and user administration capabilities.
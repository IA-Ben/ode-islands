REPLIT PROMPT — Full Auth Review & Remediation (End-User + Admin)
Objectives

End users and admins log in once; app recognises the session (no “Log in” loop).

One session model (HttpOnly cookie), one /api/me.

RBAC gates Admin routes; Settings only for owner|admin.

Works on localhost and production domains (cookie attributes correct).

Clean out stale/duplicate auth.

Deliverables

✅ Single source of truth for auth (remove legacy).

✅ OAuth login → callback → HttpOnly session cookie set correctly.

✅ /api/me returns { user } with roles.

✅ App shell revalidates user state post-login (no manual refresh).

✅ RBAC middleware for /admin/* + server-side action checks.

✅ Logout clears session; optional refresh token rotation.

✅ Test checklist all green (see bottom).

Remove legacy / duplicates (delete or replace)

Old endpoints: /api/login, /api/auth/* from previous providers (Clerk/Auth0/etc.).

Client-side token storage in localStorage/sessionStorage.

Multiple cookie names (token, auth, sessionId). Keep only session (and optional refresh).

Duplicate guards/components showing “Log in”—centralise on /api/me.

Environment (Replit Secrets)
REPLIT_AUTH_CLIENT_ID=xxx
REPLIT_AUTH_CLIENT_SECRET=xxx
REPLIT_AUTH_ISSUER=https://replit.com
APP_URL=https://<your-app-or-admin-url>   # e.g. https://ode.repl.co or custom
JWT_PRIVATE_KEY=-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----
JWT_PUBLIC_KEY=-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----
NODE_ENV=production                         # or development
SESSION_TTL_MINUTES=15
REFRESH_TTL_DAYS=14

Session model (authoritative)

session cookie: short-lived JWT (RS256), HttpOnly.

refresh cookie (optional): opaque token or JWT, HttpOnly; used to mint new session.

Cookies:

Local dev: SameSite=Lax, Secure=false, no Domain.

Prod, same-site: SameSite=Lax, Secure=true.

Prod, cross-site (IdP ↔ app domains differ): SameSite=None; Secure. Only set Domain=.yourdomain.com if app/admin share the parent domain.

Routes & middleware
1) /auth/login (redirect to Replit with PKCE)

Create state + code_verifier (PKCE).

Store in short-lived HttpOnly temp cookies.

Redirect to Replit Auth with code_challenge=S256.

// app/auth/login/route.ts
import { cookies } from "next/headers"; import crypto from "crypto";
export async function GET() {
  const state = crypto.randomBytes(16).toString("hex");
  const verifier = crypto.randomBytes(32).toString("base64url");
  const challenge = crypto.createHash("sha256").update(verifier).digest("base64url");
  cookies().set("pkce_state", state,   { httpOnly: true, sameSite: "lax", path: "/" });
  cookies().set("pkce_verifier", verifier, { httpOnly: true, sameSite: "lax", path: "/" });

  const auth = new URL(`${process.env.REPLIT_AUTH_ISSUER}/auth`);
  auth.searchParams.set("client_id", process.env.REPLIT_AUTH_CLIENT_ID!);
  auth.searchParams.set("redirect_uri", `${process.env.APP_URL}/api/auth/callback/replit`);
  auth.searchParams.set("response_type", "code");
  auth.searchParams.set("scope", "openid email profile");
  auth.searchParams.set("state", state);
  auth.searchParams.set("code_challenge", challenge);
  auth.searchParams.set("code_challenge_method", "S256");
  return Response.redirect(auth.toString(), 302);
}

2) /api/auth/callback/replit (verify + exchange + set cookies)

Verify state; exchange code (+ PKCE verifier) for tokens.

Fetch userinfo; map to local user/roles; sign session JWT; set cookies; clear temp cookies; redirect to post-login route.

// app/api/auth/callback/replit/route.ts
import { cookies } from "next/headers"; import jwt from "jsonwebtoken";
const isDev = process.env.NODE_ENV !== "production";
export async function GET(req: Request) {
  const url = new URL(req.url);
  const code = url.searchParams.get("code"); const state = url.searchParams.get("state");
  const jar = cookies(); const savedState = jar.get("pkce_state")?.value; const verifier = jar.get("pkce_verifier")?.value;
  if (!code || !state || state !== savedState) return new Response("Invalid state", { status: 400 });

  // TODO: call Replit token endpoint with code+verifier; fetch userinfo
  const user = { id: "u123", email: "dev@example.com", roles: ["admin"] }; // <- replace with real result

  const session = jwt.sign(
    { sub: user.id, email: user.email, roles: user.roles },
    process.env.JWT_PRIVATE_KEY!, { algorithm: "RS256", expiresIn: `${process.env.SESSION_TTL_MINUTES || 15}m` }
  );

  jar.set("session", session, {
    httpOnly: true, secure: !isDev, sameSite: isDev ? "lax" : "none", path: "/"
    // domain: ".yourdomain.com" // only if app/admin share parent in prod
  });

  jar.delete("pkce_state"); jar.delete("pkce_verifier");
  return Response.redirect(`${process.env.APP_URL}/auth/post-login`, 302);
}

3) /auth/post-login (client: revalidate state & route)

Revalidate /api/me, then replace to last page (or /app/event).

// app/auth/post-login/page.tsx
"use client";
import { useEffect } from "react"; import { useRouter } from "next/navigation"; import { mutate } from "swr";
export default function PostLogin(){ const r = useRouter(); useEffect(()=>{ mutate("/api/me"); r.replace("/app/event"); },[]); return null; }

4) /api/me (single source of truth)

Parse session cookie; return { user } or { user: null }.

// app/api/me/route.ts
import { cookies } from "next/headers"; import jwt from "jsonwebtoken";
export async function GET(){ const t = cookies().get("session")?.value;
  if(!t) return Response.json({ user:null });
  try { const u = jwt.verify(t, process.env.JWT_PUBLIC_KEY!, { algorithms:["RS256"], clockTolerance: 5 });
        return Response.json({ user: u }); }
  catch { return Response.json({ user:null }); }
}

5) /api/auth/logout

Clear session (and refresh if used); redirect home.

// app/api/auth/logout/route.ts
import { cookies } from "next/headers";
export async function POST(){ const jar=cookies(); jar.delete("session"); jar.delete("refresh"); return new Response(null,{status:204}); }

6) Admin RBAC (middleware + server checks)

Middleware denies non-admins at /admin/*.

Server actions call requireAuth(action) with role mapping.

// middleware.ts (scoped to /admin)
import { NextResponse } from "next/server"; import type { NextRequest } from "next/server"; import jwt from "jsonwebtoken";
const ALLOWED=new Set(["owner","admin","producer","operator","analyst","support"]);
export function middleware(req: NextRequest){
  if(!req.nextUrl.pathname.startsWith("/admin")) return NextResponse.next();
  const token = req.cookies.get("session")?.value; if(!token) return NextResponse.redirect(new URL("/auth/login", req.url));
  try { const u:any = jwt.verify(token, process.env.JWT_PUBLIC_KEY!, { algorithms:["RS256"], clockTolerance: 5 });
        if((u.roles??[]).some((r:string)=>ALLOWED.has(r))) return NextResponse.next();
        return NextResponse.redirect(new URL("/no-access", req.url)); } catch { return NextResponse.redirect(new URL("/auth/login", req.url)); }
}


Server-side action policy (authoritative):

// rbac.ts
type Role="owner"|"admin"|"producer"|"operator"|"analyst"|"support";
type Action="read"|"create"|"update"|"delete"|"publish"|"archive"|"adjust_points"|"award_memory"|"remint_nft"|"settings";
const POLICY:Record<Role,Action[]>={ owner:["read","create","update","delete","publish","archive","adjust_points","award_memory","remint_nft","settings"],
 admin:["read","create","update","delete","publish","archive","adjust_points","award_memory","remint_nft","settings"],
 producer:["read","create","update","delete","publish","archive"],
 operator:["read","award_memory"], analyst:["read"], support:["read","award_memory","remint_nft","adjust_points"] };
export const can=(role:Role,action:Action)=>POLICY[role]?.includes(action);

Front-end: unify header and state

App/Admin top bar uses the same UnifiedTopBar; after login, the header must fetch /api/me and re-render.

On route mount (layout level), call /api/me via SSR or SWR; do not rely on stale client state.

Quick SWR example:

const { data } = useSWR("/api/me", (u)=>fetch(u).then(r=>r.json()));
const user = data?.user; // if truthy, show Profile/Wallet/Tier; else show "Log in"

CORS & CSRF (if using API from another origin)

Keep cookies HttpOnly; for cross-site API calls, allow credentials and set SameSite=None; Secure.

For state-changing endpoints (POST/PATCH/DELETE), require:

CSRF token header OR same-site check on Origin/Referer.

Server-side requireAuth(action).

Security hardening

PKCE + state already included.

RS256 JWT with clockTolerance 5–10s to smooth skew.

Rotate keys via JWKS if possible; otherwise rotate env keys periodically.

NTP time sync on server/container.

Short session (e.g., 15m) + silent refresh behind /api/auth/refresh if needed.

SSO between App and Admin

If App (app.yourdomain.com) and Admin (admin.yourdomain.com) both trust the same session:

Set cookie Domain=.yourdomain.com, Secure=true.

Keep SameSite=Lax for same-site, or None if you ever bounce via third-party.

Clean-up: map & delete old code

Search repo for token, auth0, clerk, localStorage auth usage.

Remove unused /pages/api/auth/* (if migrating to App Router).

Ensure exactly one source of /api/me; deprecate others.

Diagnostics (what to check when it “still says log in”)

Callback response has Set-Cookie: session=... and it is not struck out in devtools.

Cookie attributes match the environment rules above.

/api/me returns user immediately after callback (no hard refresh).

Middleware lets you into /admin with admin roles and blocks others.

Time is in sync; no JWT “nbf/exp” complaints.

Tests (must pass)

T1 Login loop: Login → Replit → back → header shows user; /api/me truthy.

T2 Cookie attrs: Dev vs Prod settings correct; cross-site uses SameSite=None; Secure.

T3 RBAC: /admin unauthenticated → /auth/login; non-admin → /no-access; admin → loads.

T4 Logout: POST /api/auth/logout clears cookie; /api/me → {user:null}.

T5 Refresh (if implemented): expired session + valid refresh silently issues a new session.

T6 CSRF: state-changing endpoints require auth and either CSRF header or same-site origin.

Optional enhancements

Deep-link mode switch (App ⇄ Admin) remembers last routes per mode.

Account linking screen for first-time Replit users to accept T&Cs.

Telemetry: log auth_login_start/success/fail, auth_callback_error, auth_refresh, rbac_denied.

This prompt gives you a clean, unified auth system for both end users and admins, eliminates duplication, and fixes the “logged in but header says Log in” issue by enforcing correct cookies, a single /api/me, and a post-login revalidation step.
REPLIT PROMPT — Fix Auth (ditch strict OIDC, use OAuth2+PKCE)
Objective

End users + admins can log in (no more loop / “Authentication failed”).

Replace openid-client@6 validation (which requires iss) with simple OAuth2 PKCE.

Keep HttpOnly session cookie, /api/me, and RBAC middleware.

One code path, prod + dev safe cookie attrs.

0) Clean up duplicates / strict libs

Uninstall or pin:

Remove: openid-client or pin to ^5.4.3 if you still want it elsewhere.

npm remove openid-client (recommended), or npm i -E openid-client@5.4.3.

Delete old handlers that used client.callback() / Issuer.discover().

1) Environment (set in Replit Secrets)
AUTH_AUTHORIZE_URL=https://<REPLIT_AUTH>/auth
AUTH_TOKEN_URL=https://<REPLIT_AUTH>/oauth/token
AUTH_USERINFO_URL=https://<REPLIT_AUTH>/oauth/userinfo
AUTH_CLIENT_ID=xxxxx
AUTH_CLIENT_SECRET=xxxxx              # only if your app uses confidential flow
APP_URL=https://<your-app-url>        # e.g., https://your-repl-name.username.repl.co
NODE_ENV=production                   # or development
JWT_PRIVATE_KEY=-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----
JWT_PUBLIC_KEY=-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----
SESSION_TTL_MINUTES=15
REFRESH_TTL_DAYS=14


If Replit uses slightly different endpoints, set them here—the code below reads only from env.

2) Implement OAuth2 + PKCE (no OIDC library)
/auth/login — start flow
// app/auth/login/route.ts
import { cookies } from "next/headers";
import crypto from "crypto";

export async function GET() {
  const state = crypto.randomBytes(16).toString("hex");
  const verifier = crypto.randomBytes(32).toString("base64url");
  const challenge = crypto.createHash("sha256").update(verifier).digest("base64url");

  // short-lived temp cookies
  cookies().set("pkce_state", state,    { httpOnly: true, sameSite: "lax", path: "/" });
  cookies().set("pkce_verifier", verifier, { httpOnly: true, sameSite: "lax", path: "/" });

  const url = new URL(process.env.AUTH_AUTHORIZE_URL!);
  url.searchParams.set("client_id", process.env.AUTH_CLIENT_ID!);
  url.searchParams.set("redirect_uri", `${process.env.APP_URL}/api/auth/callback/replit`);
  url.searchParams.set("response_type", "code");
  url.searchParams.set("scope", "openid email profile"); // harmless if provider ignores
  url.searchParams.set("state", state);
  url.searchParams.set("code_challenge", challenge);
  url.searchParams.set("code_challenge_method", "S256");

  return Response.redirect(url.toString(), 302);
}

/api/auth/callback/replit — exchange code, set session
// app/api/auth/callback/replit/route.ts
import { cookies } from "next/headers";
import jwt from "jsonwebtoken";

const isDev = process.env.NODE_ENV !== "production";

async function fetchToken(code: string, verifier: string) {
  const body = new URLSearchParams({
    grant_type: "authorization_code",
    code,
    redirect_uri: `${process.env.APP_URL}/api/auth/callback/replit`,
    client_id: process.env.AUTH_CLIENT_ID!,
    code_verifier: verifier,
  });
  // If confidential client:
  if (process.env.AUTH_CLIENT_SECRET) body.set("client_secret", process.env.AUTH_CLIENT_SECRET);

  const r = await fetch(process.env.AUTH_TOKEN_URL!, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body,
  });
  if (!r.ok) throw new Error(`token_exchange_failed ${r.status}`);
  return r.json() as Promise<{ access_token: string; id_token?: string; token_type: string; expires_in?: number }>;
}

async function fetchUserinfo(accessToken: string) {
  const r = await fetch(process.env.AUTH_USERINFO_URL!, {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  if (!r.ok) throw new Error(`userinfo_failed ${r.status}`);
  return r.json() as Promise<{ sub: string; email?: string; name?: string; picture?: string }>;
}

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const code = url.searchParams.get("code");
    const state = url.searchParams.get("state");
    const jar = cookies();
    const savedState = jar.get("pkce_state")?.value;
    const verifier = jar.get("pkce_verifier")?.value;

    if (!code || !state || state !== savedState || !verifier) {
      return new Response("Invalid state", { status: 400 });
    }

    const token = await fetchToken(code, verifier);
    const profile = await fetchUserinfo(token.access_token);

    // Map Replit profile → app user
    const user = {
      id: profile.sub,
      email: profile.email ?? "",
      name: profile.name ?? "",
      roles: deriveRolesFromEmail(profile.email), // implement: owner|admin|...
    };

    const session = jwt.sign(
      { sub: user.id, email: user.email, name: user.name, roles: user.roles },
      process.env.JWT_PRIVATE_KEY!,
      { algorithm: "RS256", expiresIn: `${process.env.SESSION_TTL_MINUTES || 15}m` }
    );

    jar.set("session", session, {
      httpOnly: true,
      secure: !isDev,
      sameSite: isDev ? "lax" : "none",
      path: "/",
      // domain: ".yourdomain.com" // only if app+admin are on subdomains in prod
    });

    // cleanup
    jar.delete("pkce_state");
    jar.delete("pkce_verifier");

    return Response.redirect(`${process.env.APP_URL}/auth/post-login`, 302);
  } catch (e) {
    console.error("oauth_callback_error", e);
    return new Response(JSON.stringify({ error: "Authentication failed" }), { status: 401 });
  }
}

// simplistic role derivation example
function deriveRolesFromEmail(email?: string): string[] {
  const adminList = (process.env.ADMIN_EMAILS ?? "").split(",").map(s => s.trim().toLowerCase());
  if (email && adminList.includes(email.toLowerCase())) return ["admin"];
  return []; // visitor by default; app RBAC will gate admin UI
}

/auth/post-login — revalidate UI
// app/auth/post-login/page.tsx
"use client";
import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { mutate } from "swr";

export default function PostLogin() {
  const r = useRouter();
  useEffect(() => {
    mutate("/api/me");      // re-read user
    r.replace("/app/event"); // or last route
  }, []);
  return null;
}

/api/me — single source of truth
// app/api/me/route.ts
import { cookies } from "next/headers";
import jwt from "jsonwebtoken";

export async function GET() {
  const token = cookies().get("session")?.value;
  if (!token) return Response.json({ user: null });
  try {
    const u = jwt.verify(token, process.env.JWT_PUBLIC_KEY!, { algorithms: ["RS256"], clockTolerance: 5 });
    return Response.json({ user: u });
  } catch {
    return Response.json({ user: null });
  }
}

/api/auth/logout — clear session
// app/api/auth/logout/route.ts
import { cookies } from "next/headers";
export async function POST() {
  const jar = cookies();
  jar.delete("session");
  return new Response(null, { status: 204 });
}

/admin/* middleware — RBAC gate
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import jwt from "jsonwebtoken";

const ALLOWED = new Set(["owner","admin","producer","operator","analyst","support"]);

export function middleware(req: NextRequest) {
  if (!req.nextUrl.pathname.startsWith("/admin")) return NextResponse.next();
  const token = req.cookies.get("session")?.value;
  if (!token) return NextResponse.redirect(new URL("/auth/login", req.url));
  try {
    const u: any = jwt.verify(token, process.env.JWT_PUBLIC_KEY!, { algorithms: ["RS256"], clockTolerance: 5 });
    const ok = (u.roles ?? []).some((r: string) => ALLOWED.has(r));
    return ok ? NextResponse.next() : NextResponse.redirect(new URL("/no-access", req.url));
  } catch {
    return NextResponse.redirect(new URL("/auth/login", req.url));
  }
}

3) Why this fixes your issue

No dependency on iss: we don’t call openid-client@6’s callback() so there’s no authorization response iss requirement.

Provider-agnostic: env points to any OAuth2 server (Replit or other).

Same UX: you still get /api/me, session cookie, RBAC, and the unified header.

4) Quick verification (do these)

Log in → callback → Network: Set-Cookie: session=… not struck out.

Immediately request /api/me → returns { user: { … } }.

Header changes from Log in to Profile/Wallet/Tier without manual refresh.

/admin:

unauthenticated → /auth/login

authenticated non-admin → /no-access

admin (email in ADMIN_EMAILS) → loads admin UI.

5) Optional: keep openid-client for discovery only

If you still want discovery (JWKS, etc.), pin:

npm i -E openid-client@5.4.3


Use it just for discovery/JWKS, but do not call client.callback(); you already exchanged tokens manually.

6) If it still fails

Post the callback response headers (particularly Set-Cookie) and the /api/me JSON immediately after login.

Check cookie attrs vs environment:

Local: SameSite=Lax; Secure=false; Domain unset.

Cross-site/prod: SameSite=None; Secure; Domain=.yourdomain.com (only if app/admin share parent).

This replaces the brittle OIDC callback path with a straightforward OAuth2 PKCE flow and keeps all of your session + RBAC behaviour intact.
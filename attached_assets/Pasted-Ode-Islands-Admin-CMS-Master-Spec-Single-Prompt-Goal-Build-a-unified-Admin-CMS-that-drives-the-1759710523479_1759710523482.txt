Ode Islands — Admin/CMS Master Spec (Single Prompt)

Goal: Build a unified Admin/CMS that drives the entire app (Story, Event, After).
Admin is visible only to authorised roles, with full config/mutations limited to owner|admin.
Design matches the new app top UI (dark glass, rounded pill sub-navs, clear focus).
Outputs versioned JSON APIs consumed by the app. Memory Wallet is global, not a card.

1) Access control (strict, enforced everywhere)

Roles: owner, admin, producer, operator, analyst, support, visitor(app).

Visibility of Admin area/menu: only if role ∈ {owner, admin, producer, support, analyst, operator}.

Capabilities

Full Admin UI (all config/mutations): owner|admin

Producer (content): create/update/publish Story, Events, Cards, Rewards; no Settings/Chains

Operator (FOH): QR/manual awards tools only; no config

Analyst: Analytics read-only

Support: user wallet/points tools (adjust, re-mint/export NFT), read content; no config

Front-end route/layout guard

// withAuthGuard.tsx
export function withAuthGuard<T>(Comp: React.ComponentType<T>, allowed: string[]) {
  return function Guard(props: T & { user?: { roles: string[] } }) {
    const roles = props.user?.roles ?? [];
    const can = roles.some(r => allowed.includes(r));
    if (!can) return <NoAccess />; // or redirect('/app')
    return <Comp {...props} />;
  };
}
// usage (Next.js)
export default withAuthGuard(AdminLayout, ["owner","admin","producer","support","analyst","operator"]);


Server/API RBAC (authoritative)

// rbac.ts
type Role = "owner"|"admin"|"producer"|"operator"|"analyst"|"support";
type Action =
  | "read"|"create"|"update"|"delete"|"publish"|"archive"
  | "adjust_points"|"award_memory"|"remint_nft"|"settings";

const POLICY: Record<Role, Action[]> = {
  owner:   ["read","create","update","delete","publish","archive","adjust_points","award_memory","remint_nft","settings"],
  admin:   ["read","create","update","delete","publish","archive","adjust_points","award_memory","remint_nft","settings"],
  producer:["read","create","update","delete","publish","archive"],
  operator:["read","award_memory"],
  analyst: ["read"],
  support: ["read","award_memory","remint_nft","adjust_points"],
};
export function can(role: Role, action: Action){ return POLICY[role]?.includes(action); }

export async function requireAuth(req, action: Action){
  const user = await getUserFromSession(req);
  if (!user) throw new HttpError(401,"Unauthenticated");
  const roles: Role[] = user.roles ?? [];
  if (!roles.some(r => can(r, action))) throw new HttpError(403,"Forbidden");
  return user;
}


UI visibility: hide Admin menu for unauthorised users; grey/lock Settings/Feature Flags unless owner|admin.

Audit everything (immutable): every mutation writes audits{actorId,scope,action,payload,createdAt}; per-record Audit drawer in CMS.

2) Global IA & design system

Top bar: Logo • Dashboard • Story Builder • Events • Cards • Rewards • Wallet • Users • Orders • Analytics • Settings • Env pill (Demo/Prod) • Profile.

Section sub-nav: sticky pill row (List | Create | Drafts | Rules | Audit | Preview).

Visuals: dark glass backgrounds, rounded controls, strong focus rings, responsive, dark/light modes; keyboard accessible.

3) Story Builder (first-class, tied to existing systems)

Purpose: author immersive narratives as Stories → Chapters → Sub-chapters → Cards with branching and rewards.

Editors

Story: title, slug, theme (colours, grid/motion), default audio, access window, status.

Chapter timeline: reorder sub-chapters; art; music bed; Draft/Scheduled/Live/Archived.

Sub-chapter canvas: drag/reorder cards; right drawer editor; live preview.

Story cards (scope "story", reuse base Card)

Types: Story Text/Image/Video/Audio/Gallery/Quote, Button-Link (to sub-chapter/AR/QR/Event card), AR block, Quest.

Reward hook (shared engine): award{enabled, templateId, trigger(onOpen|onComplete|onShare|onChoice|minScore), cooldownSec?, oneTime?} → emits Points + Memory → global Wallet animation.

AI-first feed: storyParams.highlightForFeed=true → exposed via /story/:id/feed.

Branching builder: conditions points≥N | tier≥X | choice==Y | qrSeen(ruleId) | geoInZone → target sub-chapter.

Scheduling: pre-event chapter drops; allow content to persist/duplicate into After.

4) Events (aligned with app)

Event Home (top-level): Quick Actions (Scan, Map, Schedule, Offers); Featured Cards (1–3) via Featured Rules (priority + conditions: time/tier/zone/popularity/manual).

Swipe lanes:

Info: Schedule, Map, Venue, Safety

Interact: Live AR, QR Scan, Wearables, AI Create, User Media

Rewards: Points/Superfan, Discounts, Merch, F&B

Card Slots: drag order, time windows, visibility (tier/geo/time).

No Memory Wallet card (Wallet is global).

5) Cards (unified library for Story + Event)

Base fields: title, subtitle, art, size(S/M/L), actions, lane(if event), order, timeWindow, visibility, analyticsTag, params.

Types: ar, qr, venueInfo, schedule, map, merch, fnb, discounts, wearables, userMedia, aiCreate, safety + story display cards.

Reward hook (all cards): toggle + templateId + trigger (onOpen|onComplete|onShare|onOrderComplete|onPair|onScore) + cooldown/one-time.

Deep links: buttons can open AR/QR/Event card or jump to sub-chapters.

6) Rewards (global engine)

Memory Templates (NFT-ready): title, image, media(image|video|ar-capture|3d glb/usdz), points, rarity, set mapping, OG share, privacy flags, NFT block (enabled, chain preset, mintMode lazy|instant, custodial, royaltyBps).

Reward Rules: QR | Geo | Action → outputs (points, templateId) with constraints (tier gate, cooldownSec, one-time, window, max redemptions). Signed QR payloads; geohash + optional dwell.

Points & Tiers: weights per action; thresholds (Bronze 0–199, Silver 200–499, Gold 500+); benefits map (discounts %, AR unlocks).

Runtime: same engine for Story & Event; awards Memory + Points; app triggers Wallet animation.

7) Wallet (global destination)

Admin config: grid defaults (Owned/All), filters, set definitions, OG share presets, delete/export policies; badge animation copy/haptics.

NFTs (MVP): implement schema + UI; mint/export behind featureFlags.nft with custodial lazy-mint mock success/fail.

Never create a Wallet card in Story or Event.

8) Users (management)

List: search; filters (role, tier, points range, hasWallet, bans).

Detail: Profile (name/email/consents/devices), Progress (points ledger, tier trajectory), Wallet (items + NFT status).

Actions: adjust points (+/– reason), manually award memory, re-mint/void NFT, export to wallet, lock/unlock, reset demo data.

Audit drawer per user.

9) Orders (Merch & F&B)

Catalogues/menus, bundles, tier price overrides, mock checkout toggle, pickup QR format, statuses (created|paid|ready|collected).

10) Analytics

Dashboards: Story progression (chapter/sub-chapter), drop-off, card CTR, Featured performance, AR launches, QR scans, Memory awards, points earned, tier distribution, checkout funnel (mock).

Events captured: card_open, card_complete, reward_rule_triggered, memory_awarded, story_branch_followed, qr_scan_success, ar_launch, order_complete.

Exports: CSV/JSON.

11) Settings

Environment (Demo/Prod), Feature Flags (nft, demoMode), chains/contracts registry, AR scenes registry (IDs, safety copy), map zones, consent/privacy text, staff device registry.

12) Data model (authoritative, minimal)

users: id, email, name, roles[], tier, points, lastSeenAt, banned{…}, consents{…}, devices[], createdAt

user_points_ledger: id, userId, delta, reason, source{eventId,cardId,ruleId}, actorAdminId?, createdAt

memory_templates: id, title, image, media{type,url}, type, points, rarity, set{id,name,total}, og{…}, privacy{…}, nft{enabled,chain,contractRef,mintMode,custodial,royaltyBps}

memories: id, userId, templateId, state(new|owned|preview), earnedAt, source{eventId,cardId?,subchapterId?,ruleId?,qrId?,sceneId?,geo?}, metadata(json), points, rarity, set{…}, shareUrl, nft{enabled,chain,contract,tokenId?,status,custodial,royaltyBps}

reward_rules: id, type(qr|geo|action), match{qr{prefix,hmac?}|geo{geohash,precision,dwellSec?}|action{name,conditions?}}, outputs{points,templateId}, constraints{tierGate,cooldownSec,oneTime,window,maxRedemptions}, status

stories: id, slug, title, theme{…}, access{start,end}, audio{…}, chapters[], status

chapters: id, storyId, title, order, art{…}, audio{…}, access{…}, subchapters[], status

subchapters: id, chapterId, title, order, cards[], branching[], status

branching: id, when[conditions], goToSubchapterId

events: id, name, dates{start,end}, venue{name}, map{zones,pins}, schedule[], featuredRules[], lanes{info[],interact[],rewards[]}, quickActions[], status

featured_rules: id, priority, conditions{time{from,to}, tierAtLeast, zones[], popularityAbove}, layout(hero|carousel), cardIds[], fallback?

cards (base): id, scope(story|event), eventId?, type, lane?, order, title, subtitle, art{image|video}, size(S|M|L), actions[], timeWindow{start,end}, visibility{minTier,geoZones[],time{start,end}}, analyticsTag, award{enabled,templateId,trigger,minScore?,cooldownSec?,oneTime?}, params{…}, storyParams{…}

orders: id, userId, eventId, type(merch|fnb), items[{sku,qty,price}], total, status, pickupQr, createdAt

audits: id, actorId, scope, action, payload(json), createdAt

settings: env(demo|prod), featureFlags{nft?:bool,demoMode?:bool}, chains[], policies{privacy,consents}

13) APIs (app consumption)

GET /story/:id → Story + Chapters + Sub-chapters + Cards (resolved); public.

GET /story/:id/feed → Suggested/flagged cards.

GET /event/:id → Event Home (Quick Actions, Featured) + lanes/cards.

GET /reward/rules & GET /memory/templates → global rewards/templates.

All payloads: include version + publishedAt for cache; support offline caching.

14) Workflows (must deliver)

Create a Story: Story → Chapters → Sub-chapters → add cards → branching → Reward hooks → Schedule/Publish.

Configure Event Home: Featured Rules (priority/conditions/layout) → pick cards → Preview → Publish.

Make any card award a Memory: toggle Reward hook → choose template → set trigger/constraints → Save → simulate in Preview.

Create QR reward: Rewards → Reward Rules (QR) → signed payload schema → outputs (points + template) → constraints → generate QR batch.

User support: search user → adjust points (ledger reason) → manual award → re-mint/export NFT (if enabled).

Audit: open record → view audit drawer; every mutation present.

15) Migration & integration (minimal)

Add columns: cards.scope("story"|"event"), cards.storyParams jsonb.

Move existing story content into stories/chapters/subchapters and link card IDs.

Backfill publish states (default draft); add indexes: audits.createdAt, memories.userId, user_points_ledger.userId.

Tie-in: Story uses same Card base, Reward engine, AR registry, and Wallet as Event.

16) Acceptance criteria

Non-admins cannot access Admin routes or see Admin menu; API denies unauthorised mutations.

Story Builder publishes chapters/sub-chapters/cards with branching + reward hooks; app renders from CMS JSON.

Event hub respects Featured Rules & lane order; any configured card can award Memories; no Wallet card exists.

Rewards engine works uniformly (QR/Geo/Action + per-card triggers).

Wallet updates globally on award; NFT UI/schema present; mint/export behind feature flag.

All mutations generate Audit entries; Analytics dashboards show events; CSV export works.

UI matches top-bar design; responsive, accessible (keyboard/focus/contrast).

Deliverables: Admin UI, RBAC, data layer, APIs, demo seed, README (deployment, flags, seeding).
import { NextRequest, NextResponse } from 'next/server';
import { db } from '../../../../../server/db';
import { userMemoryWallet, memoryTemplates } from '../../../../../shared/schema';
import { eq, and } from 'drizzle-orm';
import { withUserAuthAndCSRF } from '../../../../../server/auth';
import { ScoringService } from '../../../../../server/scoringService';

interface AwardMemoryRequest {
  templateId: string;
  source: string;
  points: number;
  eventId?: string;
  chapterId?: string;
  cardIndex?: number;
  metadata?: Record<string, any>;
}

async function handlePOST(request: NextRequest) {
  try {
    const session = (request as any).session;

    if (!session || !session.isAuthenticated) {
      return NextResponse.json(
        { success: false, message: 'Authentication required to award memory' },
        { status: 401 }
      );
    }

    const body: AwardMemoryRequest = await request.json();
    const {
      templateId,
      source,
      points,
      eventId,
      chapterId,
      cardIndex,
      metadata = {},
    } = body;

    if (!templateId || !source) {
      return NextResponse.json(
        { success: false, message: 'Template ID and source are required' },
        { status: 400 }
      );
    }

    // Get memory template
    const template = await db
      .select()
      .from(memoryTemplates)
      .where(eq(memoryTemplates.id, templateId))
      .limit(1);

    if (!template || template.length === 0) {
      return NextResponse.json(
        { success: false, message: 'Memory template not found' },
        { status: 404 }
      );
    }

    const memoryTemplate = template[0];

    // Check if user already has this memory from this source
    const existing = await db
      .select()
      .from(userMemoryWallet)
      .where(
        and(
          eq(userMemoryWallet.userId, session.userId),
          eq(userMemoryWallet.sourceType, 'card'),
          eq(userMemoryWallet.sourceId, source)
        )
      )
      .limit(1);

    if (existing && existing.length > 0) {
      return NextResponse.json(
        {
          success: false,
          message: 'Memory already collected from this source',
          alreadyCollected: true,
        },
        { status: 409 }
      );
    }

    // Create memory in wallet
    const memoryData = {
      userId: session.userId,
      title: memoryTemplate.title,
      description: memoryTemplate.description,
      mediaUrl: memoryTemplate.mediaUrl,
      mediaType: memoryTemplate.mediaType as 'image' | 'video' | 'audio' | 'text' | null,
      thumbnail: memoryTemplate.thumbnail,
      sourceType: 'card' as const,
      sourceId: source,
      sourceMetadata: JSON.stringify({
        templateId,
        ...metadata,
      }),
      eventId: eventId || null,
      chapterId: chapterId || null,
      cardIndex: cardIndex || null,
      collectionTrigger: 'card_action',
      collectionContext: JSON.stringify({
        action: metadata.action || 'open',
        timestamp: new Date().toISOString(),
      }),
      memoryCategory: memoryTemplate.category,
      emotionalTone: memoryTemplate.emotionalTone,
      autoGenerated: true,
      isFavorite: false,
      tags: JSON.stringify(memoryTemplate.tags || []),
    };

    const [memory] = await db
      .insert(userMemoryWallet)
      .values(memoryData)
      .returning();

    // Award fan score points
    const scoringService = new ScoringService();
    const awardResult = await scoringService.award(session.userId, {
      activityType: 'memory_collection',
      referenceType: 'card',
      referenceId: source,
      eventId: eventId || undefined,
      chapterId: chapterId || undefined,
      cardIndex: cardIndex || undefined,
      metadata: {
        templateId,
        memoryId: memory.id,
        pointsAwarded: points,
        ...metadata,
      },
    });

    if (!awardResult.success) {
      console.warn('Failed to award points for memory collection:', awardResult.error);
    }

    return NextResponse.json({
      success: true,
      memory: {
        id: memory.id,
        title: memory.title,
        thumbnail: memory.thumbnail,
      },
      points: awardResult.success ? awardResult.pointsAwarded : 0,
      totalPoints: awardResult.success ? awardResult.newTotalScore : 0,
      level: awardResult.success ? awardResult.newLevel : 1,
      message: `Memory saved! +${points} pts`,
    });
  } catch (error) {
    console.error('Memory award error:', error instanceof Error ? error.message : String(error));
    return NextResponse.json(
      { success: false, message: 'Failed to award memory' },
      { status: 500 }
    );
  }
}

export const POST = withUserAuthAndCSRF(handlePOST);

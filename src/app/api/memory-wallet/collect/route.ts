import { NextRequest, NextResponse } from 'next/server';
import { db } from '../../../../../server/db';
import { userMemoryWallet, liveEvents, userProgress } from '../../../../../shared/schema';
import { eq, and } from 'drizzle-orm';
import { withUserAuthAndCSRF } from '../../../../../server/auth';
import { ScoringService } from '../../../../../server/scoringService';
import crypto from 'crypto';

// Import QR validation functions from the QR validation API
// CRC32 implementation for offline QR validation
function crc32(data: string): number {
  const table = [];
  let crc = 0;
  
  // Generate CRC32 table
  for (let i = 0; i < 256; i++) {
    crc = i;
    for (let j = 0; j < 8; j++) {
      crc = (crc & 1) ? (0xEDB88320 ^ (crc >>> 1)) : (crc >>> 1);
    }
    table[i] = crc;
  }
  
  crc = 0xFFFFFFFF;
  
  for (let i = 0; i < data.length; i++) {
    crc = table[(crc ^ data.charCodeAt(i)) & 0xFF] ^ (crc >>> 8);
  }
  
  return (crc ^ 0xFFFFFFFF) >>> 0;
}

// Generate CRC32 checksum for QR code data
function generateQRCRC(qrData: string): string {
  const baseData = qrData.replace(/\|CRC:[^|]*/, '');
  const checksum = crc32(baseData);
  return checksum.toString(16).padStart(8, '0').toUpperCase();
}

// QR Code Security Configuration (same as validation API)
const QR_SECRET = process.env.QR_SECRET || (() => {
  if (process.env.NODE_ENV === 'production') {
    throw new Error('QR_SECRET environment variable is required in production');
  }
  console.warn('⚠️  WARNING: QR_SECRET not set, using default for development only');
  return 'dev-qr-secret-change-in-production-with-256-bit-key';
})();

// Parse and validate QR code for chapter sources
function parseAndValidateQR(qrData: string): {
  isValid: boolean;
  eventId?: string;
  chapterId?: string;
  sequenceId?: string;
  error?: string;
} {
  try {
    if (!qrData.startsWith('E:')) {
      return { isValid: false, error: 'Invalid QR format' };
    }

    const parts = qrData.split('|');
    const parsed: any = {};

    for (const part of parts) {
      const [key, value] = part.split(':', 2);
      switch (key) {
        case 'E': parsed.eventId = value; break;
        case 'C': parsed.chapterId = value; break;
        case 'S': parsed.sequenceId = value; break;
        case 'V': parsed.version = value; break;
        case 'H': parsed.hmac = value; break;
        case 'T': parsed.timestamp = value; break;
        case 'N': parsed.nonce = value; break;
        case 'CRC': parsed.crc = value; break;
      }
    }

    // Validate required fields
    if (!parsed.eventId || !parsed.chapterId || !parsed.sequenceId || 
        !parsed.version || !parsed.hmac) {
      return { isValid: false, error: 'Missing required QR fields' };
    }

    // Verify HMAC integrity
    let dataToSign = `E:${parsed.eventId}|C:${parsed.chapterId}|S:${parsed.sequenceId}|V:${parsed.version}`;
    
    if (parsed.timestamp) dataToSign += `|T:${parsed.timestamp}`;
    if (parsed.nonce) dataToSign += `|N:${parsed.nonce}`;

    const expectedHmac = crypto
      .createHmac('sha256', QR_SECRET)
      .update(dataToSign)
      .digest('hex')
      .substring(0, 16);

    const hasValidHmac = parsed.hmac === expectedHmac;

    // Verify CRC if present
    let hasValidCrc = true;
    if (parsed.crc) {
      const expectedCrc = generateQRCRC(qrData);
      hasValidCrc = parsed.crc.toUpperCase() === expectedCrc;
    }

    if (!hasValidHmac || !hasValidCrc) {
      return { 
        isValid: false, 
        error: !hasValidHmac ? 'QR signature verification failed' : 'QR checksum verification failed'
      };
    }

    return {
      isValid: true,
      eventId: parsed.eventId,
      chapterId: parsed.chapterId,
      sequenceId: parsed.sequenceId
    };
  } catch (error) {
    return { isValid: false, error: 'QR parsing error' };
  }
}

// Collect a memory from various sources (cards, chapters, events)
async function handlePOST(request: NextRequest) {
  try {
    const session = (request as any).session;

    if (!session || !session.isAuthenticated) {
      return NextResponse.json(
        { success: false, message: 'Authentication required to collect memory' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const {
      sourceType,
      sourceId,
      eventId,
      chapterId,
      cardIndex,
      title,
      description,
      mediaUrl,
      mediaType,
      thumbnail,
      collectionTrigger,
      collectionContext,
      memoryCategory,
      emotionalTone,
      sourceMetadata,
      autoGenerated = true,
      qrData, // QR code data for chapter sources (REQUIRED for security)
    } = body;

    // Validate required fields
    if (!sourceType || !title) {
      return NextResponse.json(
        { success: false, message: 'Source type and title are required' },
        { status: 400 }
      );
    }

    // SECURITY: Mandatory QR validation for chapter sources
    if (sourceType === 'chapter') {
      if (!qrData) {
        return NextResponse.json(
          { 
            success: false, 
            message: 'QR code data is required for chapter memory collection',
            error: 'QR_REQUIRED' 
          },
          { status: 400 }
        );
      }

      // Validate QR code cryptographically
      const qrValidation = parseAndValidateQR(qrData);
      if (!qrValidation.isValid) {
        console.warn(`Invalid QR for chapter collection by user ${session.userId}: ${qrValidation.error}`);
        return NextResponse.json(
          { 
            success: false, 
            message: `QR validation failed: ${qrValidation.error}`,
            error: 'QR_INVALID' 
          },
          { status: 400 }
        );
      }

      // Ensure QR data matches the chapter being collected
      if (qrValidation.chapterId !== chapterId) {
        return NextResponse.json(
          { 
            success: false, 
            message: 'QR code does not match the chapter being collected',
            error: 'QR_CHAPTER_MISMATCH' 
          },
          { status: 400 }
        );
      }

      // Ensure QR event matches (if eventId provided)
      if (eventId && qrValidation.eventId !== eventId) {
        return NextResponse.json(
          { 
            success: false, 
            message: 'QR code does not match the event context',
            error: 'QR_EVENT_MISMATCH' 
          },
          { status: 400 }
        );
      }

      // Additional verification: check if event exists and is active
      try {
        const event = await db
          .select({ id: liveEvents.id, isActive: liveEvents.isActive })
          .from(liveEvents)
          .where(eq(liveEvents.id, qrValidation.eventId!))
          .limit(1);

        if (event.length === 0 || !event[0].isActive) {
          return NextResponse.json(
            { 
              success: false, 
              message: 'Event not found or not active',
              error: 'EVENT_INVALID' 
            },
            { status: 400 }
          );
        }
      } catch (dbError) {
        console.error('Event validation error:', dbError);
        return NextResponse.json(
          { 
            success: false, 
            message: 'Event validation failed',
            error: 'EVENT_CHECK_FAILED' 
          },
          { status: 500 }
        );
      }

      console.log(`QR validated for chapter collection: user=${session.userId}, chapter=${qrValidation.chapterId}, event=${qrValidation.eventId}`);
    }

    // Check if memory already exists for this source to prevent duplicates
    const conditions = [
      eq(userMemoryWallet.userId, session.userId),
      eq(userMemoryWallet.sourceType, sourceType)
    ];
    
    if (sourceId) conditions.push(eq(userMemoryWallet.sourceId, sourceId));
    if (eventId) conditions.push(eq(userMemoryWallet.eventId, eventId));
    if (chapterId) conditions.push(eq(userMemoryWallet.chapterId, chapterId));
    if (cardIndex !== undefined) conditions.push(eq(userMemoryWallet.cardIndex, cardIndex));

    const existingMemory = await db
      .select()
      .from(userMemoryWallet)
      .where(and(...conditions))
      .limit(1);

    if (existingMemory.length > 0) {
      return NextResponse.json(
        { 
          success: false, 
          message: 'Memory already collected from this source',
          existingMemory: {
            id: existingMemory[0].id,
            title: existingMemory[0].title,
            collectedAt: existingMemory[0].collectedAt
          }
        },
        { status: 409 }
      );
    }

    // Prepare memory data for collection
    const memoryData = {
      userId: session.userId,
      title,
      description,
      mediaUrl,
      mediaType,
      thumbnail,
      sourceType,
      sourceId,
      sourceMetadata: JSON.stringify(sourceMetadata || {}),
      eventId,
      chapterId,
      cardIndex: cardIndex !== undefined ? parseInt(cardIndex) : null,
      collectionTrigger: collectionTrigger || (autoGenerated ? 'auto' : 'manual'),
      collectionContext: JSON.stringify({
        ...collectionContext,
        autoGenerated,
        timestamp: new Date().toISOString(),
        userAgent: request.headers.get('user-agent') || 'unknown',
        qrValidated: sourceType === 'chapter', // Track if QR was validated
        qrData: sourceType === 'chapter' ? qrData : undefined, // Store QR for audit trail
      }),
      memoryCategory: memoryCategory || 'moment',
      emotionalTone: emotionalTone || 'positive',
      isFavorite: false, // Default to not favorite when auto-collected
    };

    // Insert memory into wallet
    const result = await db
      .insert(userMemoryWallet)
      .values(memoryData)
      .returning();

    const memory = result[0];

    // Award fan scoring points after successful memory collection
    const scoringService = new ScoringService();
    try {
      await scoringService.award(session.userId, {
        activityType: 'memory_collect',
        referenceType: sourceType,
        referenceId: sourceId || memory.id,
        eventId: eventId || undefined,
        chapterId: chapterId || undefined,
        cardIndex: cardIndex !== undefined ? parseInt(cardIndex) : undefined,
        metadata: {
          memoryTitle: title,
          memoryCategory: memoryCategory || 'moment',
          collectionTrigger: collectionTrigger || (autoGenerated ? 'auto' : 'manual'),
          autoGenerated,
          mediaType: mediaType || 'unknown'
        }
      });
    } catch (scoringError) {
      console.error('Memory collection scoring error:', scoringError);
      // Don't fail the main operation due to scoring errors
    }

    // Process the returned memory for response
    const processedMemory = {
      ...memory,
      tags: typeof memory.tags === 'string' ? JSON.parse(memory.tags || '[]') : memory.tags || [],
      sourceMetadata: typeof memory.sourceMetadata === 'string' ? JSON.parse(memory.sourceMetadata || '{}') : memory.sourceMetadata || {},
      collectionContext: typeof memory.collectionContext === 'string' ? JSON.parse(memory.collectionContext || '{}') : memory.collectionContext || {},
    };

    return NextResponse.json({
      success: true,
      memory: processedMemory,
      message: `Memory collected from ${sourceType} successfully`,
    });

  } catch (error) {
    console.error('Memory collection error:', error instanceof Error ? error.message : String(error));
    return NextResponse.json(
      { success: false, message: 'Failed to collect memory' },
      { status: 500 }
    );
  }
}

// Check if a memory can be collected (e.g., preview before collection)
async function handleGET(request: NextRequest) {
  try {
    const session = (request as any).session;

    if (!session || !session.isAuthenticated) {
      return NextResponse.json(
        { success: false, message: 'Authentication required' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const sourceType = searchParams.get('sourceType');
    const sourceId = searchParams.get('sourceId');
    const eventId = searchParams.get('eventId');
    const chapterId = searchParams.get('chapterId');
    const cardIndex = searchParams.get('cardIndex');

    if (!sourceType) {
      return NextResponse.json(
        { success: false, message: 'Source type is required' },
        { status: 400 }
      );
    }

    // Check if memory already exists
    const checkConditions = [
      eq(userMemoryWallet.userId, session.userId),
      eq(userMemoryWallet.sourceType, sourceType)
    ];
    
    if (sourceId) checkConditions.push(eq(userMemoryWallet.sourceId, sourceId));
    if (eventId) checkConditions.push(eq(userMemoryWallet.eventId, eventId));
    if (chapterId) checkConditions.push(eq(userMemoryWallet.chapterId, chapterId));
    if (cardIndex) checkConditions.push(eq(userMemoryWallet.cardIndex, parseInt(cardIndex)));

    const existingMemory = await db
      .select({
        id: userMemoryWallet.id,
        title: userMemoryWallet.title,
        collectedAt: userMemoryWallet.collectedAt,
        memoryCategory: userMemoryWallet.memoryCategory,
      })
      .from(userMemoryWallet)
      .where(and(...checkConditions))
      .limit(1);

    return NextResponse.json({
      success: true,
      canCollect: existingMemory.length === 0,
      existingMemory: existingMemory.length > 0 ? existingMemory[0] : null,
      message: existingMemory.length > 0 
        ? 'Memory already collected from this source'
        : 'Memory can be collected'
    });

  } catch (error) {
    console.error('Memory collection check error:', error instanceof Error ? error.message : String(error));
    return NextResponse.json(
      { success: false, message: 'Failed to check memory collection status' },
      { status: 500 }
    );
  }
}

export const POST = withUserAuthAndCSRF(handlePOST);
export const GET = withUserAuthAndCSRF(handleGET);
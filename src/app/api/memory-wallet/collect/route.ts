import { NextRequest, NextResponse } from 'next/server';
import { db } from '../../../../../server/db';
import { userMemoryWallet } from '../../../../../shared/schema';
import { eq, and } from 'drizzle-orm';
import { withUserAuthAndCSRF } from '../../../../../server/auth';
import { ScoringService } from '../../../../../server/scoringService';

// Collect a memory from various sources (cards, chapters, events)
async function handlePOST(request: NextRequest) {
  try {
    const session = (request as any).session;

    if (!session || !session.isAuthenticated) {
      return NextResponse.json(
        { success: false, message: 'Authentication required to collect memory' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const {
      sourceType,
      sourceId,
      eventId,
      chapterId,
      cardIndex,
      title,
      description,
      mediaUrl,
      mediaType,
      thumbnail,
      collectionTrigger,
      collectionContext,
      memoryCategory,
      emotionalTone,
      sourceMetadata,
      autoGenerated = true, // Whether this was automatically generated or user-initiated
    } = body;

    // Validate required fields
    if (!sourceType || !title) {
      return NextResponse.json(
        { success: false, message: 'Source type and title are required' },
        { status: 400 }
      );
    }

    // Check if memory already exists for this source to prevent duplicates
    const conditions = [
      eq(userMemoryWallet.userId, session.userId),
      eq(userMemoryWallet.sourceType, sourceType)
    ];
    
    if (sourceId) conditions.push(eq(userMemoryWallet.sourceId, sourceId));
    if (eventId) conditions.push(eq(userMemoryWallet.eventId, eventId));
    if (chapterId) conditions.push(eq(userMemoryWallet.chapterId, chapterId));
    if (cardIndex !== undefined) conditions.push(eq(userMemoryWallet.cardIndex, cardIndex));

    const existingMemory = await db
      .select()
      .from(userMemoryWallet)
      .where(and(...conditions))
      .limit(1);

    if (existingMemory.length > 0) {
      return NextResponse.json(
        { 
          success: false, 
          message: 'Memory already collected from this source',
          existingMemory: {
            id: existingMemory[0].id,
            title: existingMemory[0].title,
            collectedAt: existingMemory[0].collectedAt
          }
        },
        { status: 409 }
      );
    }

    // Prepare memory data for collection
    const memoryData = {
      userId: session.userId,
      title,
      description,
      mediaUrl,
      mediaType,
      thumbnail,
      sourceType,
      sourceId,
      sourceMetadata: JSON.stringify(sourceMetadata || {}),
      eventId,
      chapterId,
      cardIndex: cardIndex !== undefined ? parseInt(cardIndex) : null,
      collectionTrigger: collectionTrigger || (autoGenerated ? 'auto' : 'manual'),
      collectionContext: JSON.stringify({
        ...collectionContext,
        autoGenerated,
        timestamp: new Date().toISOString(),
        userAgent: request.headers.get('user-agent') || 'unknown',
      }),
      memoryCategory: memoryCategory || 'moment',
      emotionalTone: emotionalTone || 'positive',
      isFavorite: false, // Default to not favorite when auto-collected
    };

    // Insert memory into wallet
    const result = await db
      .insert(userMemoryWallet)
      .values(memoryData)
      .returning();

    const memory = result[0];

    // Award fan scoring points after successful memory collection
    const scoringService = new ScoringService();
    try {
      await scoringService.award(session.userId, {
        activityType: 'memory_collect',
        referenceType: sourceType,
        referenceId: sourceId || memory.id,
        eventId: eventId || undefined,
        chapterId: chapterId || undefined,
        cardIndex: cardIndex !== undefined ? parseInt(cardIndex) : undefined,
        metadata: {
          memoryTitle: title,
          memoryCategory: memoryCategory || 'moment',
          collectionTrigger: collectionTrigger || (autoGenerated ? 'auto' : 'manual'),
          autoGenerated,
          mediaType: mediaType || 'unknown'
        }
      });
    } catch (scoringError) {
      console.error('Memory collection scoring error:', scoringError);
      // Don't fail the main operation due to scoring errors
    }

    // Process the returned memory for response
    const processedMemory = {
      ...memory,
      tags: typeof memory.tags === 'string' ? JSON.parse(memory.tags || '[]') : memory.tags || [],
      sourceMetadata: typeof memory.sourceMetadata === 'string' ? JSON.parse(memory.sourceMetadata || '{}') : memory.sourceMetadata || {},
      collectionContext: typeof memory.collectionContext === 'string' ? JSON.parse(memory.collectionContext || '{}') : memory.collectionContext || {},
    };

    return NextResponse.json({
      success: true,
      memory: processedMemory,
      message: `Memory collected from ${sourceType} successfully`,
    });

  } catch (error) {
    console.error('Memory collection error:', error instanceof Error ? error.message : String(error));
    return NextResponse.json(
      { success: false, message: 'Failed to collect memory' },
      { status: 500 }
    );
  }
}

// Check if a memory can be collected (e.g., preview before collection)
async function handleGET(request: NextRequest) {
  try {
    const session = (request as any).session;

    if (!session || !session.isAuthenticated) {
      return NextResponse.json(
        { success: false, message: 'Authentication required' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const sourceType = searchParams.get('sourceType');
    const sourceId = searchParams.get('sourceId');
    const eventId = searchParams.get('eventId');
    const chapterId = searchParams.get('chapterId');
    const cardIndex = searchParams.get('cardIndex');

    if (!sourceType) {
      return NextResponse.json(
        { success: false, message: 'Source type is required' },
        { status: 400 }
      );
    }

    // Check if memory already exists
    const checkConditions = [
      eq(userMemoryWallet.userId, session.userId),
      eq(userMemoryWallet.sourceType, sourceType)
    ];
    
    if (sourceId) checkConditions.push(eq(userMemoryWallet.sourceId, sourceId));
    if (eventId) checkConditions.push(eq(userMemoryWallet.eventId, eventId));
    if (chapterId) checkConditions.push(eq(userMemoryWallet.chapterId, chapterId));
    if (cardIndex) checkConditions.push(eq(userMemoryWallet.cardIndex, parseInt(cardIndex)));

    const existingMemory = await db
      .select({
        id: userMemoryWallet.id,
        title: userMemoryWallet.title,
        collectedAt: userMemoryWallet.collectedAt,
        memoryCategory: userMemoryWallet.memoryCategory,
      })
      .from(userMemoryWallet)
      .where(and(...checkConditions))
      .limit(1);

    return NextResponse.json({
      success: true,
      canCollect: existingMemory.length === 0,
      existingMemory: existingMemory.length > 0 ? existingMemory[0] : null,
      message: existingMemory.length > 0 
        ? 'Memory already collected from this source'
        : 'Memory can be collected'
    });

  } catch (error) {
    console.error('Memory collection check error:', error instanceof Error ? error.message : String(error));
    return NextResponse.json(
      { success: false, message: 'Failed to check memory collection status' },
      { status: 500 }
    );
  }
}

export const POST = withUserAuthAndCSRF(handlePOST);
export const GET = withUserAuthAndCSRF(handleGET);